#+PROPERTY: session *python*
#+PROPERTY: results output

* env setup
** mac
** win
** lin

* rec-sys
** some definitions from the lit
"In a typical recommender sys tem people provide recommendations as
inputs, which the system then aggregates and directs to appropriate
recipients." -- Resnick and Varian, 1997

"Collaborative filtering simply means that people collaborate to help
one another perform filtering by recording their reactions to
documents they read." -- Goldberg et al, 1992

"In its most common formulation, the recommendation problem is reduced
to the problem of estimating ratings for the items that have not been
seen by a user. Intuitively, this estimation is usually based on the
ratings given by this user to other items and on some other
information [...] Once we can estimate ratings for the yet unrated
items, we can recommend to the user the item(s) with the highest
estimated rating(s)." -- Adomavicius and Tuzhilin, 2005

** goal
#+begin_src latex
  \forall{u \in U}, i^* = \argmax_{i \in I} S(u,i)
#+end_src
** problem statement
|---+---+---+---+---|
| ? | ? | 4 | ? | 1 |
|---+---+---+---+---|
| 3 | ? | ? | 2 | 2 |
|---+---+---+---+---|
| 3 | ? | ? | ? | ? |
|---+---+---+---+---|
| ? | 1 | 2 | 1 | 1 |
|---+---+---+---+---|
| ? | ? | ? | ? | ? |
|---+---+---+---+---|
| 2 | ? | 2 | ? | ? |
|---+---+---+---+---|
| ? | ? | ? | ? | ? |
|---+---+---+---+---|
| 3 | 1 | 5 | ? | ? |
|---+---+---+---+---|
| ? | ? | ? | ? | 2 |
|---+---+---+---+---|
** content-based (or content-based filtering)
Generic expression: 
#+begin_src latex
 \hat{r}_{u,i} = aggr_{i' \in I_u} r_{u,i'}
#+end_src

*** show this is kind of a 'row based' approach
** collaborative filtering
Generic expression:
#+begin_src latex
 \hat{r}_{u,i} = aggr_{u' \in U_i} r_{u',i} 
#+end_src
*** show this is kind of a 'col based' approach
** hybrid solutions

** challenges
*** new user problem
*** new item problem
*** data sparsity

* roadmap for this tutorial
What exactly are we going to do?
** goal
The goal of this tutorial is to provide you with a hands-on overview
of a few of the libraries from the scientific and data analysis
communities.
*** numpy
*** scipy
*** matplotlib
*** pandas
*** scikits-learn
*** pytables

*** optional
Pydata is 
- the name of a conference;
- a community of users and developers of data analysis tools in
  Python;
- an unbrella project for several data-related packages.

** description of the datasets we're going to use

** flow chart: the big picture

* numpy: numerical python
** what is it?
From the user's guide: "It is a Python library that provides a
multidimensional array object, various derived objects (such as masked
arrays and matrices), and an assortment of routines for fast
operations on arrays, including mathematical, logical, shape
manipulation, sorting, selecting, I/O, discrete Fourier transforms,
basic linear algebra, basic statistical operations, random simulation
and much more."
** numpy's basic data structure: the ndarray
A container for data to be passed between algorithms. Also, libraries
written in a lower-level language, such as C or Fortran, can operate
on the data stored in a NumPy array without copying any data.
#+begin_src python
  import numpy as np
  np.array([0,9,5,4,3])
  
#+end_src

#+RESULTS:

*** structure: header and payload, why this is important
** dtype
describes type, sizeof, byte order, record, subarray
** shape
** ndarrays as the building blocks for pydata
** indexing
*** std
*** fancy
*** views
** vectorization
** broadcasting rules
** arbitrary data-types

* a typical example using the movielens dataset
This is from "Python for Data Analysis", a great book on these topics
that I highly recommend. Let's start by importing the data.

#+begin_src python
import pandas as pd

unames = ['user_id', 'gender', 'age', 'occupation', 'zip']
users = pd.read_table('data/ml-1m/users.dat', sep='::', header=None, names=unames)

rnames = ['user_id', 'movie_id', 'rating', 'timestamp']
ratings = pd.read_table('data/ml-1m/ratings.dat', sep='::', header=None, names=rnames)

mnames = ['movie_id', 'title', 'genres']
movies = pd.read_table('data/ml-1m/movies.dat', sep='::', header=None, names=mnames)

#+end_src

Now, transform the frame into a ratings matrix. We'll use the convention for now that a rating of zero is

#+begin_src python
ratings_mtx_df = ratings.pivot_table(values='rating',rows='user_id',cols='movie_id')
ratings_mtx = ratings_mtx_df.as_matrix()
#+end_src

Load the an example ratings matrix from the MovieLens group and
compute some basic stats from this matrix.

#+BEGIN_SRC python
# ratings_mtx = np.loadtxt(...)
ratings_density = ratings_mtx[ratings_mtx >= 1].size / ratings_mtx.size
ratings_sparsity = 1 - ratings_density
from scipy.stats.stats import nanmean
row_mean = nanmean(ratings_mtx, axis=0)
col_mean = nanmean(ratings_mtx, axis=1)
#+END_SRC

* first look at our grocery domain dataset 
The first portion of our dataset is called an incidence matrix. This
is a |U| x |I| matrix that shows the relationship between users and
items. An entry in row u and column i is 1 if user u and item i are
related, and zero if they are not. In our context, related means 'has
ever purchased'.


#+begin_src python
  import numpy as np

  inc_mtx = np.loadtxt(open('data/inc_mtx_10k_1k.csv', 'r'), delimiter=',')
  inc_mtx.shape
  inc_mtx.size
  
#+end_src

Let's compute some basic stats from this matrix
#+begin_src python  
  tot_sum = inc_mtx.sum()
  row_sum = inc_mtx.sum(axis=0) 
  col_sum = inc_mtx.sum(axis=1)

  # ratio of ones and zeros to total entries
  density = tot_sum / inc_mtx.size
  sparsity = 1.0 - density

  # most popular item
  i_popular = np.argmax(row_sum)
  # user with the most purchases
  u_spender = np.argmax(col_sum)

#+end_src

#+RESULTS:

* pandas
** what is it?

** series: labelled arrays
what problem do they solve?
** dataframe: an extension of series similar to R's frame DS

* pytables
** what is it?

* ?
#+begin_src python
  import numpy as np
  items_mtx = np.array([[0.9,  0  , 0  ],  # viewed by 1
                        [1,    0.1, 0.1],  # viewed by 1
                        [0,    0.5, 0  ],  # viewed by 2
                        [0.1,  0.4, 0  ],  # viewed by 2
                        [0,    0.3, 0  ]])  # ?
  
  def aggr(mtx):
      return np.mean(mtx)
  
  # build profiles
  user_1_profile = aggr(items_mtx[[0,1]])
  user_2_profile = aggr(items_mtx[[2,3]])
  
  
  def sim(v1, v2):
      pass
  
  # recommend!
  estimated_rating_1_4 = sim(user_1_profile, items_mtx[4])
  
#+end_src

#+RESULTS:
: None










* numpy questions
** how do you access individual elements in a multidimensional array?
** how do you access the last column of every matrix in a 3d array?
** if i have a multidimensional array 'arr' with shape (x,y,z), what will the shape of arr[0] be?
** show how the broadcasting rule for scalars and arrays applies to the assignment operator
** select all rows from a matrix whose sum is larger than a given value x

